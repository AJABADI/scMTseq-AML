[
["index.html", "scMTseq of AML cells - pilot Data", " scMTseq of AML cells - pilot Al J Abadi 2018-11-29 Data Data from Dr Heather Lee lab from The University of Newcastle. The cells are from the Kasumi-1 AML cell line. Cell identifiers are given by a letter (indicating plate row), and a number (indicating plate column), e.g. A7, C10. scRNA-seq Data Count matrices which are quality controlled. scBS-seq Data Each .cov file in which each line is a cytosine residue, and the columns are as follows: These reports are produced by Bismark. The functional element is ill defined. Sometimes we look at promoters, sometimes enhancers, sometimes unbiased - occasionally overlapping - 3kb windows to ensure minimisation of missed genomic features. 40 cells amcth those from RNA-seq. ## update as needed. ## installing the required packages for this analysis, if necessary required.pkgs = c(&#39;mixOmics&#39;,&#39;SingleCellExperiment&#39;,&#39;scran&#39;,&#39;data.table&#39;, &#39;DESeq2&#39;, &#39;edgeR&#39;, &#39;Rtsne&#39;, &#39;ggplot2&#39;, &#39;ggrepel&#39;, &#39;gridExtra&#39;, &#39;grid&#39;, &#39;reshape2&#39;, ## for summarising &#39;seqinr&#39;, &#39;stringr&#39;, &#39;doParallel&#39;, &#39;argparse&#39; ) ## make sure Biocmanager is installed if (!requireNamespace(&#39;BiocManager&#39;, quietly = T)){ paste(&#39;Trying to install BiocManager&#39;) install.packages(&#39;BiocManager&#39;) } ## package installer function - for those not already installed package.installer = function(pkgs=required.pkgs){ for (package in pkgs){ if (!requireNamespace(package, quietly = T)){ paste0(&#39;Trying to install &#39;, package) BiocManager::install(package, update = F) } } } ## run function package.installer(required.pkgs) ## check for validity of inputs stopifnot(file.exists(io$rna_file), !io$use.parsed||file.exists(io$met_1bp_out), io$use.parsed||file.exists(io$bedfiles)) ## for reproducibility set.seed(1234321) "],
["scrna-seq-data.html", "Chapter 1 scRNA-seq Data 1.1 Load Raw Data 1.2 Preprocessing 1.3 Normalization 1.4 Dimension reduction", " Chapter 1 scRNA-seq Data ## libraries suppressPackageStartupMessages(library(mixOmics)) suppressPackageStartupMessages(library(SingleCellExperiment)) suppressPackageStartupMessages(library(data.table)) suppressPackageStartupMessages(library(scran)) suppressPackageStartupMessages(library(scater)) suppressPackageStartupMessages(library(DESeq2)) suppressPackageStartupMessages(library(edgeR)) suppressPackageStartupMessages(library(Rtsne)) suppressPackageStartupMessages(library(ggplot2)); theme_set(theme_bw()) suppressPackageStartupMessages(library(ggrepel)) suppressPackageStartupMessages(library(gridExtra)) suppressPackageStartupMessages(library(grid)) suppressPackageStartupMessages(library(reshape2)) 1.1 Load Raw Data # system.time({ ## user system elapsed ## 1.025 0.068 1.152 ## read raw scRNAseq counts counts.raw = read.csv(io$rna_file) ## create rownames using the first column rownames(counts.raw) = counts.raw[,1] counts.raw = counts.raw[,-1] head(colnames(counts.raw)) ## [1] &quot;X180924_A10_S10.bam&quot; &quot;X180924_A2_S2.bam&quot; &quot;X180924_A3_S3.bam&quot; ## [4] &quot;X180924_A4_S4.bam&quot; &quot;X180924_A5_S5.bam&quot; &quot;X180924_A6_S6.bam&quot; ## change the cell names based on well names source(&#39;utils//name.cells.by.wells.R&#39;) colnames(counts.raw) = name.cells.by.wells(colnames(counts.raw), pos.in.string = &#39;middle&#39;) head(colnames(counts.raw)) ## [1] &quot;A10&quot; &quot;A2&quot; &quot;A3&quot; &quot;A4&quot; &quot;A5&quot; &quot;A6&quot; ## create sce object from raw counts sce.rna = SingleCellExperiment(assays = list(counts = as.matrix(counts.raw))) # }) 1.2 Preprocessing 1.2.1 QC metrics ## add QC metrics sce.rna = scater::calculateQCMetrics(sce.rna) 1.2.2 Cell QC ## show lib. size and the gene expression histograms par(mfrow=c(1,2)) hist(sce.rna$total_counts/1e3, xlab=&quot;Library sizes (thousands)&quot;, main=&quot;&quot;, breaks=20, col=&quot;grey80&quot;, ylab=&quot;Number of cells&quot;) hist(sce.rna$total_features_by_counts, xlab=&quot;Number of expressed genes&quot;, main=&quot;&quot;, breaks=20, col=&quot;grey80&quot;, ylab=&quot;Number of cells&quot;) Figure 1.1: Histograms of cell QC metrics including the library sizes and number of expressed genes 1.2.3 Detect outliers ## lib size too small - 3.5 median abs. deviation less than median ## chose 3.5 MAD instead of 3 as we don&#39;t want to lose the precious cells! libsize.drop = isOutlier(sce.rna$total_counts, nmads=3.5, type=&quot;lower&quot;, log=TRUE) sum(libsize.drop) ## nothing dropped ## [1] 0 ## expressing low genes feature.drop = isOutlier(sce.rna$total_features_by_counts, nmads=3, type=&quot;lower&quot;, log=TRUE) sum(feature.drop) ## nothing dropped ## [1] 0 All cells passed QC metrics for lib size and gene expression 1.2.4 Gene Filtering 1.2.4.1 using mean expression ## histogram of log mean counts for all genes avg.count.cutoff = 1 ## for log2count = 1 ## get size factors sce.rna = computeSumFactors(sce.rna) ## Warning in FUN(...): not enough cells in at least one cluster for some ## &#39;sizes&#39; ave.counts = calcAverage(sce.rna, use_size_factors=T) log2.raw = log2(ave.counts) hist = hist(log2.raw, breaks=100, plot = F) cuts = cut(hist$breaks, c(-Inf,avg.count.cutoff , Inf)) plot(hist, col=c(&#39;red&#39;, &#39;green&#39;)[cuts], xlab=expression(Log[2]~&quot;average count of genes&quot;), main=paste0(&quot; Histogram of mean expression. \\n The green are kept: &quot;,sum(log2.raw&gt;avg.count.cutoff), &#39; out of &#39;, length(log2.raw) )) Figure 1.2: Histogram of log mean counts for all genes - red shows mean log expression below the assigned cutoff ## remove lowly expressed genes (&lt;2; log2 &lt;1) to.keep = log2.raw &gt; avg.count.cutoff sce.rna = sce.rna[to.keep,] 11703 genes passed filtering. 1.3 Normalization 1.3.1 scran ## use scran to pool cells based on gene expression similarity and calculate size factors system.time({ ## user system elapsed ## 0.366 0.027 0.435 sce.rna.scran = computeSumFactors(sce.rna) ## normalise using calculated size factors sce.rna.scran = normalize(sce.rna.scran) summary(sizeFactors(sce.rna.scran)) plot(sizeFactors(sce.rna.scran), sce.rna$total_counts/1e3, log=&quot;xy&quot;, pch=16, col=&#39;purple&#39;, ylab=&quot;Library size (thousands)&quot;, xlab=&quot;Size factor&quot;, main = &quot;Scran Size Factors&quot;) }) Figure 1.3: Size factors from deconvolution, plotted against library sizes for all cells. Axes are shown on a log-scale. Since we have similar cell types (and not much DE genes) we expect to see less scatter around the trend line, whcih is the case in this plot. ## user system elapsed ## 0.313 0.013 0.341 1.3.2 TMM (edgeR) ## TMM ## create singlecellexperiment object with edgeR normalisation factors sce.rna.TMM = sce.rna sizeFactors(sce.rna.TMM) = calcNormFactors(counts(sce.rna.TMM)) sce.rna.TMM = normalize(sce.rna.TMM) summary(sizeFactors(sce.rna.TMM)) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.8867 0.9653 0.9968 1.0000 1.0365 1.1381 plot(sizeFactors(sce.rna.TMM), sce.rna$total_counts/1e3, log=&quot;xy&quot;, pch=16, col=&#39;purple&#39;, ylab=&quot;Library size (thousands)&quot;, xlab=&quot;Size factor&quot;, main = &quot;TMM Size Factors&quot;) Figure 1.4: Size factors from TMM method. A trend line is not apparent. 1.3.3 DESeq2 sce.rna.DESeq2 = sce.rna sizeFactors(sce.rna.DESeq2) = estimateSizeFactorsForMatrix(counts(sce.rna.DESeq2)) ## normalize using scater sce.rna.DESeq2 = normalize(sce.rna.DESeq2) summary(sizeFactors(sce.rna.DESeq2)) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.4731 0.8474 0.9542 1.0000 1.1308 1.7616 plot(sizeFactors(sce.rna.DESeq2), sce.rna$total_counts/1e3, log=&quot;xy&quot;, pch=16, col = &#39;purple&#39;, ylab=&quot;Library size (thousands)&quot;, xlab=&quot;Size factor&quot;, main = &quot;DESeq2 Size Factors&quot;) Figure 1.5: Size factors from DESeq2 method. 1.4 Dimension reduction We will use Scran and DESeq2 normalisation for dimension reduction. 1.4.1 PCA 1.4.1.1 scran ## scran pca.scran = pca(t(logcounts(sce.rna.scran)), ncomp = 5) source(&#39;utils/plot.pca.R&#39;) plot.pca(pca.scran, top = &#39;scran-normalised&#39;) 1.4.1.2 DESeq2 ## DESeq2 pca.DESeq2 = pca(t(logcounts(sce.rna.DESeq2)), ncomp = 5) par(mfrow=c(2,2)) plot.pca(pca.DESeq2, top = &#39;DESeq2-normalised&#39;) 1.4.2 Hierarchical Clustering 1.4.2.1 HVGs HVGs are chosen based on highest biological CVs which have a minimum mean expression specified source(&#39;utils/calc.cv.R&#39;) n.hvgs = 500 ## number of scRNAseq HVGs to keep for clustering ## get a matrix of every gene&#39;s mean expression and BCV and order genes by BCV and plot BCV vs mean expression; order HVGs scran.gene.cv = calc.cv(logcounts(sce.rna.scran), mean.expr.cutoff = 5, n.hvgs = n.hvgs) ## plot mean expression vs sd and cv scran.gene.cv$plot.cv Figure 1.6: SD and biological CV against average counts (mean expression) hvgs = rownames(scran.gene.cv$expr.smry)[1:n.hvgs] ## reduce sce object sce.rna.scran.hvg = sce.rna.scran[hvgs,] 1.4.2.2 Euclidean Distance plotHeatmap(sce.rna.scran.hvg, features = rownames(sce.rna.scran.hvg)) Figure 1.7: Hierarchical clustering using highly variable genes - Euclidean Distance 1.4.2.3 Pearson’s r plotHeatmap(sce.rna.scran.hvg, features = rownames(sce.rna.scran.hvg), clutering_distance_rows = &#39;correlation&#39;, clutering_distance_cols = &#39;correlation&#39;) Figure 1.8: Hierarchical clustering using highly variable genes - Pearson’s r 1.4.3 tSNE For reduced scran-normaised matrix. We get some clusters when perplexity is really low: par(mfrow=c(1,2)) set.seed(12321) scran.tsne = Rtsne(t(logcounts(sce.rna.scran.hvg)), perplexity = 2) plot(scran.tsne$Y, main = &#39;tSNE - Perplexity = 2&#39;, pch=16, col=&#39;blue&#39;, xlab = &#39;tSNE-1&#39;, ylab=&#39;tSNE-2&#39;) set.seed(12321) scran.tsne = Rtsne(t(logcounts(sce.rna.scran.hvg)), perplexity = 8) plot(scran.tsne$Y, main = &#39;tSNE - Perplexity = 8&#39;, pch=16, col=&#39;blue&#39;, xlab = &#39;tSNE-1&#39;, ylab=&#39;&#39;) Figure 1.9: tSNE plots using HVGs 1.4.4 Looking at UMAP library(umap) ## UMAP on scran-normalised umap.scran.hvg = umap(t(logcounts(sce.rna.scran.hvg))) plot(umap.scran.hvg$layout, main = &#39;UMAP using HVGs&#39;, pch=16, col=&#39;blue&#39;, xlab = &#39;umap-1&#39;, ylab=&#39;umap-2&#39;) Figure 1.10: UMAP plot using HVGs "],
["scbs-seq-data.html", "Chapter 2 scBS-seq Data 2.1 Methylation and RNAseq 2.2 3kb Windows", " Chapter 2 scBS-seq Data 2.1 Methylation and RNAseq # load(file.path(io$outdir,save.name)) # system.time({ ## user system elapsed ## 4.890 0.830 4.893 ## choose sce.rna.scran as default rna sce ## HVGs will be considred based on methylation later load(file.path(io$RData,&#39;sce.rna.scran.RData&#39;)) rna.sce = sce.rna.scran ## load the methylation data met = fread(io$met_1bp_out) annos = unique(met$anno) ## get annotations ## keep only the well number as the sample name # unique(met$sample) ## the following code is fast but only works if the well names are 2 character long and at the beginning on the string ## if wells such as A12 are present (with 3 or more characters) the function name.cells.by.wells should be called met$sample = substr(met$sample,0,2) length(unique(met$sample)) ## [1] 40 length(colnames(rna.sce)) ## [1] 78 ## find the common cells in both studies cell.intersect = Reduce(intersect, list(unique(met$sample), colnames(rna.sce))) length(cell.intersect) ## [1] 40 ## keep only common cells met = met[sample %in% cell.intersect] rna.sce = rna.sce[,colnames(rna.sce) %in% cell.intersect] ## create a data.table of rates and weights where genes are rows and samples are columns for each annotation # for (i in annos[c(1,4)]){ ## only genebody and promoter for now # ## create the rate matrix for each annotation # assign(paste0(&#39;met.&#39;,i,&#39;.rate&#39;), # dcast(met[anno==i], id~sample, value.var = &#39;rate&#39;)) # # ## create the weight matrix for each annotation # assign(paste0(&#39;met.&#39;,i,&#39;.weight&#39;), # dcast(met[anno==i], id~sample, value.var = &#39;weight&#39;)) # # } ## methylation in genebody met.genebody.rate = dcast(met[anno==&#39;genebody&#39;], id~sample, value.var = &#39;rate&#39;) rownames(met.genebody.rate) = met.genebody.rate$id met.genebody.rate$id = NULL ## methylation in promoters met.prom.rate = dcast(met[anno==&#39;prom&#39;], id~sample, value.var = &#39;rate&#39;) rownames(met.prom.rate) = met.prom.rate$id met.prom.rate$id = NULL ## create sce from genebody and promoter methylation data met.gene.sce = SingleCellExperiment(assays = list(counts = as.matrix(met.genebody.rate))) met.prom.sce = SingleCellExperiment(assays = list(counts = as.matrix(met.prom.rate))) # }) 2.1.1 Filtering NAs ## How many NAs in each gene? Out of 40 cells metNAs.gene = rowSums(is.na(counts(met.gene.sce))) metNAs.prom = rowSums(is.na(counts(met.prom.sce))) hist(metNAs.gene, main = &#39;histogram of NAs for all genes - gene body&#39;, xlab = &#39;Number of NA cells&#39;) hist(metNAs.prom, main = &#39;histogram of NAs for all genes - promoter&#39;, xlab = &#39;Number of NA cells&#39;) The promoter methylation data contain much more NAs, as expected. NA.threshold=20 ## number of cells having NA values ## filter those with number of NAs more than NA.threshold met.gene.sce.filt_NAs = met.gene.sce[names(metNAs.gene[metNAs.gene&lt;=NA.threshold]),] met.prom.sce.filt_NAs = met.prom.sce[names(metNAs.prom[metNAs.prom&lt;=NA.threshold]),] ## number of genes/cells in filtered SCEs dim(met.gene.sce.filt_NAs) ## [1] 15930 40 dim(met.prom.sce.filt_NAs) ## [1] 6364 40 2.1.2 HVGs in Methylation Data source(&#39;utils/calc.cv.R&#39;) n.met.hvgs = 500 genebody.exp.smry = calc.cv(counts(met.gene.sce.filt_NAs), mean.expr.cutoff = 0, n.hvgs = n.met.hvgs, mean.quant = 0, type = &#39;Genebody Methylation Rate&#39;) genebody.exp.smry$plot.cv met.hvgs.gene = rownames(genebody.exp.smry$expr.smry)[1:n.met.hvgs] prom.exp.smry = calc.cv(counts(met.prom.sce.filt_NAs), mean.expr.cutoff = 0, n.hvgs = n.met.hvgs, mean.quant = 0, type = &#39;Promoter Methylation Rate&#39;) prom.exp.smry$plot.cv met.hvgs.prom = rownames(prom.exp.smry$expr.smry)[1:n.met.hvgs] ## HVGs for genebody met.gene.sce.filt_NAs.hvg = met.gene.sce.filt_NAs[met.hvgs.gene,] ## HVGs for promoters met.prom.sce.filt_NAs.hvg = met.prom.sce.filt_NAs[met.hvgs.prom,] &lt;!–&gt; impute using DeepCpG and plot the heatmaps: ## hclust and heatmap for genebody methylation plotHeatmap(met.gene.sce.filt_NAs.hvg, features = rownames(met.gene.sce.filt_NAs.hvg), exprs_values = &quot;counts&quot;, zlim = c(0,100), clutering_distance_rows = &#39;correlation&#39;, clutering_distance_cols = &#39;correlation&#39;) &lt;–&gt; 2.1.3 sPLS - Gene Body spls.rna.gene = spls(X=t(counts(met.gene.sce.filt_NAs.hvg )), Y=t(logcounts(rna.sce)), ncomp = 2, keepX = c(50,50), keepY= c(50,50), mode = &quot;canonical&quot;) ## Warning in cor(A[[k]], variates.A[[k]]): the standard deviation is zero plotVar(spls.rna.gene, legend=T, pch=c(16,17), title = &#39;Correlation Circle Plots - Transcriptome (Y) against gene body methylation (X) \\n No NA filtering&#39;, col= color.mixo(c(2,1))) A negative correlation between RNAseq and Methylation data is apparent, while the opoposite is also true at for some latent variables. 2.1.4 sPLS - Promoter spls.rna.prom = spls(X=t(counts(met.prom.sce.filt_NAs.hvg )), Y=t(logcounts(rna.sce)), ncomp = 2, keepX = c(50,50), keepY= c(50,50), mode = &quot;canonical&quot;) ## Warning in cor(A[[k]], variates.A[[k]]): the standard deviation is zero plotVar(spls.rna.prom, legend=T, pch=c(20,17), title = &#39;Correlation Circle Plots - Transcriptome (Y) against gene promoter methylation (X) \\n No NA filtering&#39;, col= color.mixo(c(4,1))) There are a lot more NaNs in promoter data than in gene body, which is why there are some data points outside the circles. 2.1.5 Block sPLS ## transcriptome (Y) against gene body and promoter methylation data (X) block.spls = block.spls(X = list(gene.met = t(counts(met.prom.sce.filt_NAs.hvg)),prom.met = t(counts(met.gene.sce.filt_NAs.hvg))), Y = t(logcounts(rna.sce)), ncomp = 2, keepX = list(gene.met =c(5,50), prom.met =c(5,50)), keepY= c(50,50), mode = &quot;canonical&quot;) ## Warning in cor(A[[k]], variates.A[[k]]): the standard deviation is zero plotVar(block.spls, legend = T, title = &#39;Correlation Circle Plots - Transcriptome against Methylation&#39;, pch = c(16,20,17), col= color.mixo(c(2,4,1))) ## Warning in cor(object$blocks[[x]], object$variates[[x]][, c(comp1, ## comp2)], : the standard deviation is zero 2.2 3kb Windows &lt;!–&gt; Add the option to re-summarise the methylation data here: if(!io$use.parsed){ } else { } &lt;–&gt; system.time({ ## user system elapsed ## 18.916 5.696 36.746 window3kb = fread(io$met_3kb) }) ## user system elapsed ## 26.339 8.019 22.520 system.time({ ## user system elapsed ## 4.073 2.501 7.482 ## create a &#39;bin&#39; variable ## using 1e5 bins made it too uniform, i.e. meth. rate ~0.75 ## sticking with the 3kb window bin.width =3e3 ## I have not differentiated between forward and backward strand, to be checked with Heather ## [Al] also, some windows overlap - this should be considered later on (weighted ovrlapping) window3kb[,bin:=ceiling(start/bin.width)] ## dropping all columns except for rates and bin window3kb = window3kb[, grepl(&#39;rate&#39;, colnames(window3kb))| grepl(&#39;bin&#39;, colnames(window3kb)), with=F] ## remove every column name that matches &#39;var&#39; - rate variance data window3kb = window3kb[,!grepl(&#39;var&#39;, colnames(window3kb)), with=F] dim(window3kb) # 1923673 41 source(&#39;utils/name.cells.by.wells.R&#39;) colnames(window3kb) = name.cells.by.wells(colnames(window3kb), pos.in.string = &#39;first&#39;) ## create a &#39;weight&#39; variable for the number of observations in each bin ## [Al] although, what also matters is the number of times each cell has been covered in total window3kb = window3kb[,weight:=.N, by = bin] # user system elapsed # 22.470 15.497 54.818 ## average over bins and disregard NAs- weights will remain the same so not excluded ## bins with no observation for a given cell will return NaNs window3kb = window3kb[,lapply(.SD,mean, na.rm=TRUE), by=bin] dim(window3kb) ## 82981 42 window3kb$n.NAs = rowSums(is.na(window3kb)) hist(window3kb$n.NAs, main=&#39;histogram of number of NAs in all 3kb windows&#39;) ## filter out NAs window3kb = window3kb[n.NAs&lt;=20] ## arbitrary dim(window3kb) ## 74171 43 }) ## user system elapsed ## 4.243 2.915 8.711 ## plot a given cell&#39;s weight plot(window3kb$weight, as.matrix(window3kb[,9]), xlim = c(0,250), main= &#39;methylation rate at each window for a \\n given cell vs the window coverage&#39;) ## part of variation in methylation is due to dropouts, i.e. low weight ## plot the boxplot of weights boxplot(window3kb$weight, horizontal=T) ## filtering by weight ## require each window to be covered at least x times min.weight = 20 ## arbitrary window3kb = window3kb[weight &gt; min.weight] dim(window3kb) ## 35431 43 - for min.weight = median ## [1] 44564 43 system.time({ ## user system elapsed ## 24.462 0.207 24.994 # ## add mean meth. rate for each bin: window3kb[,mean:=apply(.SD,1, mean, na.rm=TRUE ) , by=bin, .SDcols=c(2:41)] ## checking whether there are near zero means for calculating cv hist(window3kb$mean, main=&#39;mean methylation rate for all cells - 3kb windows&#39;) min(window3kb$mean)## 0.5275498 ## so we&#39;ll calculate cv with no pseudo value at denominator window3kb[,sd:=apply(.SD,1, sd, na.rm=TRUE) , by=bin,.SDcols=c(2:41)] window3kb[,cv:=sd/mean] hist(window3kb$cv) ## order by cv for highly varibale regions window3kb=window3kb[order(-cv)] ## keep the top variable windows n.region = 5000 window3kb.hvw=window3kb[1:n.region] ## create SCE hvw.sce = SingleCellExperiment(assays = list(counts = as.matrix(window3kb.hvw[,c(2:41)]))) }) ## user system elapsed ## 33.614 0.700 34.823 2.2.1 Dimension Reduction system.time({ ## user system elapsed ## 253.382 31.798 286.293 # pca.met.window = pca(t(counts(hvw.sce)), ncomp = 3) # save(pca.met.window, file= file.path(io$RData,&#39;pca.met.window.RData&#39;)) load(file.path(io$RData,&#39;pca.met.window.RData&#39;)) }) ## user system elapsed ## 0.030 0.004 0.047 ## outliers exist: source(&#39;utils/plot.pca.R&#39;) plot.pca(gg.pca = gg.pca, pca.obj = pca.met.window, top = &#39;PCA - methylation in variable 3kb windows&#39;) ## TableGrob (3 x 2) &quot;arrange&quot;: 5 grobs ## z cells name grob ## 1 1 (2-2,1-1) arrange gtable[layout] ## 2 2 (2-2,2-2) arrange gtable[layout] ## 3 3 (3-3,1-1) arrange gtable[layout] ## 4 4 (3-3,2-2) arrange gtable[layout] ## 5 5 (1-1,1-2) arrange text[GRID.text.970] ## find outliers variates =as.data.frame(pca.met.window$variates$X) variates.ordered = variates[order((abs(variates$PC1)+abs(variates$PC2)+abs(variates$PC3)), decreasing = T),] ## plot labeled pca to find outliers ggplot(variates.ordered, aes(x = PC1, y = PC2)) + geom_point(size = 3, col=color.mixo(1)) + geom_label_repel( aes(label = ifelse(rank(PC1)&lt;10,rownames(variates),&#39;&#39;)), col = &#39;darkorange&#39;, fontface = &#39;bold&#39;, box.padding = unit(0.35, &quot;lines&quot;), point.padding = unit(0.5, &quot;lines&quot;), segment.color = &#39;grey50&#39; ) ## if filtering necessary # outlier.cells = c(&#39;A7&#39;,&#39;A5&#39;,&#39;A6&#39;, &#39;A8&#39;, &#39;A9&#39;) ## Were the A row&#39;s conditions different? spls.rna.hvw = spls(Y=t(logcounts(rna.sce)), X=t(counts(hvw.sce)), ncomp = 2, keepX = c(50,50), keepY= c(50,50), mode = &quot;canonical&quot;) ## Warning in cor(A[[k]], variates.A[[k]]): the standard deviation is zero ## the data points for methylation data represents an unbaised bin plotVar(spls.rna.hvw, legend = T, title = paste0(&#39;Correlation Circle Plots - Transcriptome (Y) against Methylation \\n of the unbiased &#39;,as.integer(bin.width/1000),&#39; kb windows (X)&#39;), pch= c(16,17), col= color.mixo(c(5,1))) Negative correlation between RNAseq and Methylation in 3kb window data. "],
["scmt-seq-analysis.html", "Chapter 3 scM&amp;T-seq analysis", " Chapter 3 scM&amp;T-seq analysis "]
]
