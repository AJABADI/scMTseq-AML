[
["index.html", "scMTseq of AML cells - pilot Data", " scMTseq of AML cells - pilot Al J Abadi 2019-02-11 Data Data from Dr Heather Lee lab from The University of Newcastle. ## update as needed. ## installing the required packages for this analysis, if necessary required.pkgs = c(&#39;mixOmics&#39;,&#39;SingleCellExperiment&#39;,&#39;scran&#39;,&#39;data.table&#39;, &#39;DESeq2&#39;, &#39;edgeR&#39;, &#39;Rtsne&#39;, &#39;ggplot2&#39;, &#39;ggrepel&#39;, &#39;gridExtra&#39;, &#39;grid&#39;, &#39;reshape2&#39;, ## for summarising &#39;seqinr&#39;, &#39;stringr&#39;, &#39;doParallel&#39;, &#39;argparse&#39; ) ## make sure Biocmanager is installed if (!requireNamespace(&#39;BiocManager&#39;, quietly = T)){ paste(&#39;Trying to install BiocManager&#39;) install.packages(&#39;BiocManager&#39;) } ## package installer function - for those not already installed package.installer = function(pkgs=required.pkgs){ for (package in pkgs){ if (!requireNamespace(package, quietly = T)){ paste0(&#39;Trying to install &#39;, package) BiocManager::install(package, update = F) } } } ## run function package.installer(required.pkgs) "],
["scrna-seq-data.html", "Chapter 1 scRNA-seq Data 1.1 Load Raw Data 1.2 Preprocessing 1.3 Normalisation 1.4 Dimension reduction - filtered genes 1.5 Dimension reduction - HVGs", " Chapter 1 scRNA-seq Data ## libraries suppressPackageStartupMessages(library(mixOmics)) suppressPackageStartupMessages(library(SingleCellExperiment)) suppressPackageStartupMessages(library(data.table)) suppressPackageStartupMessages(library(scran)) suppressPackageStartupMessages(library(scater)) suppressPackageStartupMessages(library(Rtsne)) suppressPackageStartupMessages(library(ggplot2)); theme_set(theme_bw()) suppressPackageStartupMessages(library(ggrepel)) suppressPackageStartupMessages(library(gridExtra)) suppressPackageStartupMessages(library(grid)) suppressPackageStartupMessages(library(reshape2)) suppressPackageStartupMessages(library(umap)) suppressPackageStartupMessages(library(magrittr)) 1.1 Load Raw Data # system.time({ ## user system elapsed ## 1.025 0.068 1.152 ## read raw scRNAseq counts counts.raw = read.csv(io$rna_file) ## create rownames using the first column rownames(counts.raw) = counts.raw[,1] ## remove the &#39;id&#39; column counts.raw = counts.raw[,-1] head(colnames(counts.raw)) ## change the cell names based on well names colnames(counts.raw) = name.cells.by.wells(colnames(counts.raw), pos.in.string = &#39;middle&#39;) head(colnames(counts.raw)) ## create sce object from raw counts rna.sce = SingleCellExperiment(assays = list(counts = as.matrix(counts.raw))) rna.sce.match = rna.sce[,met.cellnames] ## matching cells # }) 1.2 Preprocessing 1.2.1 QC metrics ## add QC metrics rna.sce = scater::calculateQCMetrics(rna.sce) 1.2.1.1 cell QC look at the histograms of library sizes and the number of genes expressed by each cell: ## look at the histograms of lib. sizes and the number of genes expressed by each cell par(mfrow=c(1,2)) hist(rna.sce$total_counts/1e6, xlab=&#39;Library sizes (millions)&#39;, main=&#39;&#39;, breaks=20, col=&#39;grey80&#39;, ylab=&#39;Number of cells&#39;) hist(rna.sce$total_features_by_counts, xlab=&#39;Number of expressed genes&#39;, main=&#39;&#39;, breaks=20, col=&#39;grey80&#39;, ylab=&#39;Number of cells&#39;) Create a list of cell QC metrics: ## keep a record of lower limit cells cell.qc = list() ## qc metric based on lib size tot.counts = rna.sce$total_counts names(tot.counts) = colnames(rna.sce) tot.counts = tot.counts[order(tot.counts)] ## from least to most libsize = list() libsize$rank = rank(tot.counts) libsize$ratio2median = tot.counts/median(tot.counts) cell.qc$libsize = libsize ## qc metric based on gene expression genes.expressed.ratio2median = rna.sce$total_features_by_counts/median(rna.sce$total_features_by_counts) names(genes.expressed.ratio2median) = colnames(rna.sce) genes.expressed.ratio2median %&gt;% .[order(.)] ## from least to most cell.qc$gene.expressed.ratio2median = genes.expressed.ratio2median Which cells are more than 3.5 median absolute deviations less than the median log library size / number of genes expressed?: libsize.drop &lt;- isOutlier(rna.sce$total_counts, nmads=3.5, type=&#39;lower&#39;, log=TRUE) colnames(rna.sce)[libsize.drop] ## the cells with low library size feature.drop &lt;- isOutlier(rna.sce$total_features_by_counts, nmads=3.5, type=&#39;lower&#39;, log=TRUE) colnames(rna.sce)[feature.drop] ## the cells with low number of expressed genes &gt; NULL For each cell, we look at number of genes expressed vs library size (ratio to the median for both): ## cells df4ggplot = data.frame(libsize = libsize$ratio2median, genes.expressed = genes.expressed.ratio2median[names(libsize$ratio2median)]) ## keep a record of lower quality cells for future reference rank.threshold = 5 ## the rank threshold on library size and gene expression df4ggplot$lower.quality = with(df4ggplot, rank(libsize)&lt;rank.threshold | rank(genes.expressed)&lt;rank.threshold) ggplot(df4ggplot, aes(x = libsize, y = genes.expressed)) + geom_point(size = 3, col=color.mixo(1)) + labs(x = &#39;Library Size / median&#39; , y=&#39; Number of genes expressed /median&#39;, title = &#39;# of genes expressed against library size for all cells. \\n cells on lower limits are labelled for downstream reference&#39;) + theme(plot.title = element_text(hjust = 0.5)) + geom_label_repel( aes(label = ifelse(lower.quality,rownames(df4ggplot),&#39;&#39;)), col = &#39;darkorange&#39;, fontface = &#39;bold&#39;, box.padding = unit(0.35, &#39;lines&#39;), point.padding = unit(0.5, &#39;lines&#39;), segment.color = &#39;grey50&#39; ) No cells are filtered at this stage. We will assess A3 and E8 further downstream. 1.2.1.2 gene filtering We require genes to have: + non-zero library size + be expressed/detected in at least 5% of cells gene.metrics = as.data.frame(rowData(rna.sce)) ## a data.frame of gene metrics gene.metrics$pass &lt;- gene.metrics$total_counts!=0 &amp; gene.metrics$pct_dropout_by_counts&lt;params$max.cell.dropout*100 sum(gene.metrics$pass) ## number of genes after this filter: 15K To also filter out noisy genes with high rate of dropouts, we usually look at the library size histogram and put a threshold between the two peaks to the left of where the fitted curve plateaues (Lun, McCarthy, and Marioni 2018). ## choose a min log lib size threshold min.libsize = log10(4) ## must be chosen based on the following hisogram ## look at only those which passed total lib size filtering and cell dropout filtering log.mean.counts = gene.metrics$log10_mean_counts ## see if you&#39;re filtering the first peak of non-zero values hist = hist(log.mean.counts[log.mean.counts&gt;0], prob=TRUE, breaks = 100, col = &#39;grey80&#39;, main= &#39;Histogram of log10 mean gene counts / library sizes&#39;, xlab = &#39;log10[mean counts] for each gene&#39;) abline(v = min.libsize, col = &#39;darkorange&#39;, lwd=2) Based on the histogam above, 0.60206 is chosen as minimum gene library size. gene.metrics$pass[gene.metrics$pass] &lt;- gene.metrics$log10_mean_counts[ gene.metrics$pass]&gt;=params$min.gene.libsize sum(gene.metrics$pass) ## number of genes after this filter: 10.7K rna_qc = rna.sce[gene.metrics$pass,] ## filter genes dim(rna_qc) ## 10778 78 1.3 Normalisation 1.3.1 scran ## use scran to pool cells based on gene expression similarity and calculate size factors system.time({ ## user system elapsed ## 0.366 0.027 0.435 rna_qc = computeSumFactors(rna_qc) ## normalise using calculated size factors rna_qc = normalize(rna_qc) }) ## size factors summary # summary(sizeFactors(rna_qc)) plot(sizeFactors(rna_qc), rna_qc$total_counts/1e3, log=&#39;xy&#39;, pch=16, col=&#39;purple&#39;, ylab=&#39;Library size (thousands)&#39;, xlab=&#39;Size factor&#39;, main = &#39;Scran Size Factors&#39;) Figure 1.1: Size factors from deconvolution, plotted against library sizes for all cells. Axes are shown on a log-scale. Since we have similar cell types (and not much DE genes) we expect to see less scatter around the trend line, whcih is the case in this plot. 1.4 Dimension reduction - filtered genes 1.4.1 PCA ## scran pca.res = pca(t(logcounts(rna_qc)), ncomp = 5) rnaseq.only = colnames(rna_qc)[! colnames(rna_qc) %in% met.cellnames] pca.grid(pca.obj = pca.res, diff.samples = rnaseq.only) ## invesigating whether there are technical effects by wells: source(&#39;utils/pca.well.R&#39;) pca.well(pca.res, PCs=c(1,2)) pca.well(pca.res, PCs=c(2,3)) There does not seems to be a grouping by well rows from PCA plots. 1.4.2 Variation Since there are technical factors that can affect capture efficiency (such as GC content for Illumina sequencing, PCR amplification noise etc), for the studies that use HVGs, we need to ensure that are gene selection is based on biological variance. 1.4.2.1 variance decomposition method By fitting a mean-depndent loess curve to variance - log expression (which makes it more robust to outliers). The fitted value of this trend represents technical variability due to sequencing, drop-outs during capture, etc. at a given mean. 1.4.2.2 How is biological variance determined? Details can be found here and here. 1.4.2.3 decompose variance ## function to decompose variance for sce and return results as rowData(sce) var.decomp = function(sce=rna_qc){ fit &lt;- trendVar(sce, method=&#39;loess&#39;, use.spikes=FALSE) ## fit a mean-dependent loess to variance decomp &lt;- as.data.frame(decomposeVar(sce, fit)) ## decompose variance to technical and biological decomp$trend.var &lt;- fit$trend(fit$means) ## add the fitted variance column rowData(sce) %&lt;&gt;% cbind(.,decomp) ## add to rowData(sce) sce %&lt;&gt;% .[order(-rowData(.)$bio),] ## order by bio variance return(sce) } ## decompose variance rna_qc %&lt;&gt;% var.decomp(.) par(mfrow=c(1,2)) row_data = rna_qc %&gt;% rowData() %&gt;% as.data.frame() ## a data.frame of rowData ## total variance (fold change compared to mean) vs log mean ggplot(row_data) + geom_point(aes(x= mean, y=total, col = FDR), show.legend = TRUE) + scale_colour_gradientn(colors = c(&#39;#027009&#39;, &#39;#aebc31&#39;), name = &#39;FDR&#39;) + geom_line(aes(x=mean, y = trend.var, fill = &#39;Fitted trend&#39;), size=2) + scale_fill_manual(&#39;&#39;, values = c(6), guide=guide_legend(override.aes = list(color=c(&#39;black&#39;)))) + labs(x=&#39;mean log expression&#39;, y = &#39;total variance&#39;, title = &#39; total variance vs log mean expression for filtered genes&#39;) ## inferred biological variance (fold change compared to mean) vs log mean ggplot(row_data) + geom_point(aes(x= mean, y=bio, col=FDR), show.legend = TRUE) + scale_colour_gradientn(colors = c(&#39;#027009&#39;, &#39;#aebc31&#39;), name = &#39;FDR&#39;) + labs(x=&#39;mean log expression&#39;, y = &#39;biological variance&#39;, title = &#39; biological variation vs log mean expression for filtered genes&#39;) 1.4.2.3.1 Pearson’s r ## hierarchical clustering using HVGs hvgs = rownames(rna_qc[1:params$rna.78cells.hvgs,]) plotHeatmap(rna_qc[hvgs,], features = hvgs, clutering_distance_rows = &#39;correlation&#39;, clutering_distance_cols = &#39;correlation&#39;, main = paste0( &#39;Clustered heatmap of scRNAseq data with &#39;,params$rna.78cells.hvgs, &#39; HVGs only \\n using Pearson correlation \\n cells at the bottom and genes on the side&#39;)) 1.5 Dimension reduction - HVGs 1.5.1 PCA using HVGS The first 2 PCs now contain ~ 13% of variation, compared to 5% which was before pca.hvgs.res = pca(t(logcounts(rna_qc[hvgs,])), ncomp = 5) pca.grid(pca.obj = pca.hvgs.res, diff.samples = rnaseq.only) 1.5.2 tSNE does not identify clear clusters par(mfrow=c(1,2)) set.seed(12321) sce.hvg.tsne = Rtsne(t(logcounts(rna_qc[hvgs,])), perplexity = 10) plot(sce.hvg.tsne$Y, main = &#39;tSNE - Perplexity = 10&#39;, pch=colnames(rna_qc), col=factor(substr(colnames(rna_qc),0,1)), xlab = &#39;tSNE-1&#39;, ylab=&#39;tSNE-2&#39;) Figure 1.2: tSNE plots using HVGs 1.5.3 UMAP does not identify clear clusters ## UMAP on scran-normalised sce.hvg.umap = umap(t(logcounts(rna_qc[hvgs,]))) plot(sce.hvg.umap$layout, main = &#39;UMAP using HVGs&#39;, pch=rownames(sce.hvg.umap$layout), col=factor(substr(rownames(sce.hvg.umap$layout),0,1)), xlab = &#39;umap-1&#39;, ylab=&#39;umap-2&#39; ) Figure 1.3: UMAP plot using HVGs colored by wells "],
["scbs-seq-data.html", "Chapter 2 scBS-seq Data 2.1 Data 2.2 Create sce 2.3 Summary 2.4 Variance 2.5 Dimension reduction", " Chapter 2 scBS-seq Data 40 cells matching RNA-seq data 2.1 Data ## load the methylation data met = fread(io$met_1bp_out) unique(met$anno) ## all annotations ## look at sample names head(unique(met$sample), 2) ## keep only the well number as the sample name ## the following code is fast but only works if the well names are 2 character long and at the beginning on the string ## if wells such as A12 are present (with 3 or more characters) the function name.cells.by.wells should be called met$sample = substr(met$sample,0,2) length(unique(met$sample)) ## 40 met =met[anno!=&#39;intergenic&#39;] ## #TODO drop intergenic for now 2.2 Create sce ## from each annotation (genebody, promoter etc) in methylation file, create a sce object ## which includes the weighted mean methylation rate (rbar) and weighted methylation variance (vhat) ## plus the coverage of the gene in rowData(sce), filter by coverage and record the changes in dim(sce) ## after filtering in metadata(sce) system.time({ ## 19 sec for (i in unique(met$anno) ) { assign(paste0(&#39;sce_&#39;,i), met_sce(met=met, annot = i, cov = params$cov.cutoff)) } }) load(file.path(params$RData,&#39;met_sces.RData&#39;)) 2.3 Summary ## get all annotations annots = grep(&#39;sce_&#39;, ls(), value=TRUE) ## tabulate metadata lapply(annots, function(x){metadata(get(x))$gene_stats}) %&gt;% lapply(., cbind) %&gt;% as.data.frame() %&gt;% kableExtra::kable(., caption = &#39;Number of genes in each dataset before and after filtering by coverage&#39;) 2.4 Variance rv_plot = function(sce = sce_genebody, annot = &#39;Gene Body Methylation&#39;){ rowdat = sce %&gt;% rowData() %&gt;% as.data.frame() ggplot(rowdat, aes(x=rbar, y=vhat, col = cov)) + geom_point() + guides(col=guide_legend(&#39;Coverage&#39;)) + labs(x=TeX(&#39;$\\\\bar{r}$&#39;), y=TeX(&#39;$\\\\hat{\\\\nu}$&#39;),title = annot) } ## plot all vhat ~ rbar par(mfrow=c(ceiling(length(annots)/2),2)) lapply(annots, function(x){rv_plot(get(x), x)}) 2.5 Dimension reduction Because of large number of NA’s, dimension reduction cannot be trusted for now. ## pca function ## sce: sce with &#39;rates&#39; assay ## ncomp: integer, number of comps to get ## hvgs: NULL or number of hvgs to keep based on rowData(sce)$vhat pca_met = function(sce = &#39;sce_genebody&#39;, ncomp = 2, n_hvgs = NULL){ rates = assay(get(sce), &#39;rates&#39;) if (!is.null(n_hvgs)){ if(n_hvgs&gt;=dim(get(sce))[1]){ message(&#39;number of genes &lt;= hvgs; all genes used&#39;) } else{ rates = rates[1:n_hvgs,] } } out = pca(t(rates), ncomp = ncomp) out$anno = gsub(&#39;sce_&#39;,&#39;&#39;, sce) return(out) } n_hvgs = params$hvgs_pca ## maximum number of components reaches for some comps system.time({ ## 562 sec for ncomp=3, nhvgs =2000 pca_out = lapply(annots, function(x){pca_met(x,ncomp = 3, n_hvgs =n_hvgs)}) save(pca_out, file=file.path(params$RData,&#39;pca_out.RData&#39;) }) load(file.path(params$RData,&#39;pca_out.RData&#39;)) lapply(pca_out, function(x){pca.grid(x, top = x$anno, point.label = TRUE)}) ## Weighted PCA? "],
["scmt-seq-analysis.html", "Chapter 3 scM&amp;T-seq analysis 3.1 Correlation 3.2 Canonical correlation study", " Chapter 3 scM&amp;T-seq analysis load(file.path(params$RData,&#39;rna_qc.RData&#39;)) load(file.path(params$RData,&#39;met_sces.RData&#39;)) ## find the common cells in both studies cell.intersect = Reduce(intersect, list(colnames(sce_genebody), colnames(rna_qc))) length(cell.intersect) ## keep only matching cells rna_match = rna_qc[,colnames(rna_qc) %in% cell.intersect] 3.1 Correlation ## gene-wise pearson correlation of methylation and expression for top `top_prop` proportion of ## common genes b/w the two datasets based on their weighted variance in methylation datasets ## stored in rowData(met_sces) ## plus ## the global correlation of biological and total variance b/w meth. and expression for all genes in metadata(met_sce) pearson_runtime = system.time({ ## 90 sec met_sces = grep(&#39;sce_&#39;, ls(), value=TRUE) for (i in met_sces){ assign(i, corr_mt(rna_match, get(i), top_prop = 0.3) ) } }) pearson_runtime %&lt;&gt;% .[1] %&gt;% unname() %&gt;% round() save(list = c(met_sces, &#39;pearson_runtime&#39;), file = file.path(params$RData,&#39;met_sces.RData&#39;)) met_sces = grep(&#39;sce_&#39;, ls(), value=TRUE) load(file.path(params$RData,&#39;met_sces.RData&#39;)) 3.1.1 Pearson correlation study of methylation rate and expression - gene wise ## function to create boxplot of pearson correlations of M&amp;T ## for all sces boxPlot = function(sces = met_sces, n_top = NULL, subTitle = &#39;top variable genes based on $\\\\hat{\\\\nu}$&#39; ){ factor_sces = NULL corr = NULL for (i in sces){ n = ifelse(is.null(n_top), dim(get(i))[1], min(n_top, dim(get(i))[1])) factor_sces = c(factor_sces, rep(i, n)) corr = c(corr,rowData(get(i)[1:n,])$corr_rna) } p = ggplot(data = NULL, aes(x = factor_sces , y=corr, fill = factor(factor_sces))) + geom_boxplot(na.rm = TRUE) + coord_flip() + labs(x = &#39;&#39;, y = &#39;Pearson correlation&#39;, title = &#39;Gene-wise correlation of methylation and transcription&#39;, subtitle = TeX(subTitle)) + guides(fill=FALSE) return(p) } ## Pearson correlation boxplots boxPlot(sces = met_sces, n_top = NULL, subTitle = &#39;top 30% variable genes based on $\\\\hat{\\\\nu}$&#39; ) 3.1.2 Does the variation in methylation in genebody correlates with variation in expression? ## initialise a data.frame to store the pearson correlation of total and biological variance... ## b/w expression and each methylation dataset var_corr = data.frame(matrix(nrow = length(met_sces),ncol = 2), row.names = met_sces ) colnames(var_corr) = c(&#39;total&#39;, &#39;biological&#39;) ## calculate them for (i in met_sces){ var_corr[i,] = c(metadata(get(i))$corr_var_tot_wtd_by_cov[1], metadata(get(i))$corr_var_bio_wtd_by_cov[1]) } ## plot ggplot() + geom_col(aes(factor(rownames(var_corr)),var_corr$total, fill = factor(rownames(var_corr))), shape=23, size=4) + guides(fill=FALSE) + labs(x = &#39;Genomic Context&#39;, y= &#39;Pearson correlation&#39;, title = &#39;Correlation of total transcrption variance \\n and weighted methylation variance&#39;) + coord_cartesian(ylim = c(-0.3, 0.3)) ggplot() + geom_col(aes(factor(rownames(var_corr)),var_corr$bio, fill = factor(rownames(var_corr))), shape=23, size=4) + guides(fill=FALSE) + labs(x = &#39;Genomic Context&#39;, y= &#39;Pearson correlation&#39;, title = &#39;Correlation of decomposed biological transcrption variance \\n and weighted methylation variance&#39;)+ coord_cartesian(ylim = c(-0.3, 0.3)) Non-CGI promoters have the highest correlation magnititude and show positive correlation when total variance is used, and negative when biological is considered. 3.2 Canonical correlation study ## dataset parameters for plot ## first one will be taken as Y, the rest X&#39;s ## all that are in the sPLS list + RNA par_plot = data.frame(row.names = c(&#39;rna_match&#39;, &#39;sce_genebody&#39;, &#39;sce_prom&#39;, &#39;sce_prom_cgi&#39;, &#39;sce_prom_noncgi&#39; ), label = c(&#39;Transcriptome&#39;,&#39;Genebody&#39;, &#39;Promoter&#39;, &#39;Promoter (CGI)&#39;, &#39;Promoter (non-CGI)&#39;), shape =c(17, 19, 15, 18, 8), ## shapes for corr circ plots col = color.mixo(c(1, 2, 4, 5, 8))) ## colors for corr circ plots 3.2.1 Trascriptome - Promoter Methylome ## spls for all methylation data against transcriptome ## function for spls using top x% variable genes from each dataset top_pct_spls = function(Top_pct = top_pct, ## portion of top genes Spls_name = NULL,## name of the spls list NZV = nzv ){ ## near-zero-variance in data? if(is.null(Spls_name)) {Spls_name = paste0(&#39;spls_all_top_&#39;, Top_pct*100,&quot;pct&quot;)} assign(Spls_name, spls_wrapper(x=2:5, block = FALSE, top_x = Top_pct, top_y = Top_pct, near_zer_var = NZV)) save(list=c(Spls_name), file=stringr::str_c(params$RData,&#39;/&#39;,Spls_name,&#39;.RData&#39; )) return(Spls_name) } ## function to create spls object name splsName = function(Top_pct = top_pct) {spls_name = paste0(&#39;spls_all_top_&#39;, Top_pct*100,&quot;pct&quot;)} 3.2.1.1 All genes top_pct = 1 ## all genes nzv = TRUE spls_name = splsName(top_pct) top_pct_spls(top_pct,Spls_name = spls_name, NZV = nzv) source(&#39;utils/spls_plot.R&#39;) spls_plot(get(spls_name), pars = par_plot) source(&#39;utils/spls_plot.R&#39;) png(filename = &#39;../output/png/plotVar_gbody_transcriptome_all_genes.png&#39;,height = 700, width = 700/0.8 ) spls_plot(spls_all, pars = par_plot[1:2,],plots = &#39;plotVar&#39;) dev.off() 3.2.1.2 using top 50% genes from each dataset: top_pct = 0.5 ## all genes nzv = TRUE spls_name = splsName(top_pct) top_pct_spls(top_pct,Spls_name = spls_name, NZV = nzv) spls_plot(get(spls_name), pars = par_plot) source(&#39;utils/spls_plot.R&#39;) png_name = str_c(&#39;../output/png/plotVar_gbody_transcriptome_top_&#39;, top_pct*100, &#39;_pct_genes_from_each.png&#39; ) png(filename = png_name, height = 700, width = 700/0.8) spls_plot(get(spls_name), pars = par_plot[1:2,],plots = &#39;plotVar&#39;) dev.off() 3.2.1.3 using top 30% genes from each dataset: top_pct = 0.3 ## all genes nzv = TRUE spls_name = splsName(top_pct) top_pct_spls(top_pct,Spls_name = spls_name, NZV = nzv) spls_plot(get(spls_name), pars = par_plot) source(&#39;utils/spls_plot.R&#39;) png_name = str_c(&#39;../output/png/plotVar_gbody_transcriptome_top_&#39;, top_pct*100, &#39;_pct_genes_from_each.png&#39; ) png(filename = png_name, height = 700, width = 700/0.8) spls_plot(get(spls_name), pars = par_plot[1:2,],plots = &#39;plotVar&#39;) dev.off() "]
]
